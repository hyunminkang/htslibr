# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title print htslib version
#' @description Print out htslib version
htslib_version <- function() {
    invisible(.Call(`_htslibr_htslib_version`))
}

#' Detect format of the file
#' @param fname the file to detect the format of
#' @return a string with the file format description
check_format <- function(fname) {
    .Call(`_htslibr_check_format`, fname)
}

#' Extract the sequences for a given region
#' @param bam the cram/bam/sam file
#' @param index the index of the cram/bam/sam file
#' @param reg the region of interest, typically in format of chr1:start-begin
#' @return a character vector with the sequences in the given region
#' @examples
#' \dontrun{count_kmer(bam, index, "chr1:10001-100050")}
extract_sequence <- function(bam, index, reg) {
    .Call(`_htslibr_extract_sequence`, bam, index, reg)
}

#' count the number of times a kmer is present in a region
#' @param bam the cram/bam/sam file
#' @param index the index of the cram/bam/sam file
#' @param reg the region of interest, typically in format of chr1:start-begin
#' @param kmer the substring to search for in the reads
#' @return a dataframe with the sequnce reads and counts of the given kmer per read (i.e. two columns)
#' @examples
#' \dontrun{count_kmer(bam, index, "chr1:10001-100050", "TTACGG")}
count_kmer <- function(bam, index, reg, kmer) {
    .Call(`_htslibr_count_kmer`, bam, index, reg, kmer)
}

#' Calculate the GC content for a region
#' @param bam the cram/bam/sam file
#' @param index the index of the cram/bam/sam file
#' @param reg the region of interest, typically in format of chr1:start-begin
#' @return a dataframe with the sequnce reads, counts of GC bases, and proportion of GC per read
#' @examples
#' \dontrun{gc_content(bam, index, "chr1:10001-100050")}
gc_content <- function(bam, index, reg) {
    .Call(`_htslibr_gc_content`, bam, index, reg)
}

#' Estimate approximate depth for each position in a given region
#' @param bam the cram/bam/sam file
#' @param index the index of the cram/bam/sam file
#' @param reg the region of interest, typically in format of chr1:start-begin
#' @description Calculate an approximate measure for a given region in a CRAM/BAM file. 
#' @details This is only an approximate depth, based on the 'fast mode' algorithm from mosdepth.
#' It allocates an array for the entire chromosome, an increments each start site and decrements
#' each end site, and then takes the cumulative sum. It does not account for mismatches in the alignment,
#' hence, the reference to an 'approximate' depth. 
#' @return a dataframe with the chrom, position, and approximate depth (three columns)
#' @examples
#' \dontrun{depth(bam, index, "chr1:10001-100050")}
depth <- function(bam, index, reg) {
    .Call(`_htslibr_depth`, bam, index, reg)
}

#' extract values from the INFO field
#' @param vcf the VCF/BCF file path
#' @param index the CSI/TBI index file path
#' @param reg a region query of the form: chr:start-end 
#' @param tag the field in the INFO field to extract. Only accepts one string value at this time. Only can extract numeric fields at the moment. 
#' @description Use this function to extract the INFO field values for a single INFO field in a give
#' region based query. 
#' @return a dataframe with the chrom, pos, and value of the given INFO field
#' @examples
#' \dontrun{extract_info(vcf, index, "1:10001-100500", "AC")}
extract_info <- function(vcf, index, reg, tag) {
    .Call(`_htslibr_extract_info`, vcf, index, reg, tag)
}

#' extract the genotypes for a given region from the GT field
#' @param vcf the VCF/BCF file path
#' @param index the CSI/TBI index file path
#' @param reg a region query of the form: chr:start-end 
#' @description Use this function to extract the genotypes from the GT field. Will return as a 
#' IntegerMatrix of dimensions haplotypes x variants. That is, each (diploid) individual will have two consecutve rows.
#' No existing support for using the phase of the genotypes (if present) or for handling missing values or
#' variable ploidy. 
#' @return a integer matrix of dimension (number of haplotypes x number of variants).
#' @examples
#' \dontrun{extract_genotypes(vcf, index, "1:10001-100500")}
extract_genotypes <- function(vcf, index, reg) {
    .Call(`_htslibr_extract_genotypes`, vcf, index, reg)
}

